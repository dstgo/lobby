// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/dstgo/lobby/server/data/ent/secondary"
	"github.com/dstgo/lobby/server/data/ent/server"
	"github.com/dstgo/lobby/server/data/ent/tag"
	"github.com/dstgo/lobby/server/data/ent/user"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type SecondaryPager struct {
	Order  secondary.OrderOption
	Filter func(*SecondaryQuery) (*SecondaryQuery, error)
}

// SecondaryPaginateOption enables pagination customization.
type SecondaryPaginateOption func(*SecondaryPager)

// DefaultSecondaryOrder is the default ordering of Secondary.
var DefaultSecondaryOrder = Desc(secondary.FieldID)

func newSecondaryPager(opts []SecondaryPaginateOption) (*SecondaryPager, error) {
	pager := &SecondaryPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultSecondaryOrder
	}
	return pager, nil
}

func (p *SecondaryPager) ApplyFilter(query *SecondaryQuery) (*SecondaryQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// SecondaryPageList is Secondary PageList result.
type SecondaryPageList struct {
	List        []*Secondary `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (s *SecondaryQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...SecondaryPaginateOption,
) (*SecondaryPageList, error) {

	pager, err := newSecondaryPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.ApplyFilter(s); err != nil {
		return nil, err
	}

	ret := &SecondaryPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := s.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		s = s.Order(pager.Order)
	} else {
		s = s.Order(DefaultSecondaryOrder)
	}

	s = s.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type ServerPager struct {
	Order  server.OrderOption
	Filter func(*ServerQuery) (*ServerQuery, error)
}

// ServerPaginateOption enables pagination customization.
type ServerPaginateOption func(*ServerPager)

// DefaultServerOrder is the default ordering of Server.
var DefaultServerOrder = Desc(server.FieldID)

func newServerPager(opts []ServerPaginateOption) (*ServerPager, error) {
	pager := &ServerPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultServerOrder
	}
	return pager, nil
}

func (p *ServerPager) ApplyFilter(query *ServerQuery) (*ServerQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ServerPageList is Server PageList result.
type ServerPageList struct {
	List        []*Server    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (s *ServerQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...ServerPaginateOption,
) (*ServerPageList, error) {

	pager, err := newServerPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.ApplyFilter(s); err != nil {
		return nil, err
	}

	ret := &ServerPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := s.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		s = s.Order(pager.Order)
	} else {
		s = s.Order(DefaultServerOrder)
	}

	s = s.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type TagPager struct {
	Order  tag.OrderOption
	Filter func(*TagQuery) (*TagQuery, error)
}

// TagPaginateOption enables pagination customization.
type TagPaginateOption func(*TagPager)

// DefaultTagOrder is the default ordering of Tag.
var DefaultTagOrder = Desc(tag.FieldID)

func newTagPager(opts []TagPaginateOption) (*TagPager, error) {
	pager := &TagPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultTagOrder
	}
	return pager, nil
}

func (p *TagPager) ApplyFilter(query *TagQuery) (*TagQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// TagPageList is Tag PageList result.
type TagPageList struct {
	List        []*Tag       `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (t *TagQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...TagPaginateOption,
) (*TagPageList, error) {

	pager, err := newTagPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.ApplyFilter(t); err != nil {
		return nil, err
	}

	ret := &TagPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := t.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		t = t.Order(pager.Order)
	} else {
		t = t.Order(DefaultTagOrder)
	}

	t = t.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type UserPager struct {
	Order  user.OrderOption
	Filter func(*UserQuery) (*UserQuery, error)
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*UserPager)

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = Desc(user.FieldID)

func newUserPager(opts []UserPaginateOption) (*UserPager, error) {
	pager := &UserPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultUserOrder
	}
	return pager, nil
}

func (p *UserPager) ApplyFilter(query *UserQuery) (*UserQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// UserPageList is User PageList result.
type UserPageList struct {
	List        []*User      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (u *UserQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...UserPaginateOption,
) (*UserPageList, error) {

	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.ApplyFilter(u); err != nil {
		return nil, err
	}

	ret := &UserPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := u.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		u = u.Order(pager.Order)
	} else {
		u = u.Order(DefaultUserOrder)
	}

	u = u.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
