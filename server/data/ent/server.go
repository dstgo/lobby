// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/dstgo/lobby/server/data/ent/server"
)

// Server is the model entity for the Server schema.
type Server struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// GUID holds the value of the "guid" field.
	GUID string `json:"guid,omitempty"`
	// RowID holds the value of the "row_id" field.
	RowID string `json:"row_id,omitempty"`
	// SteamID holds the value of the "steam_id" field.
	SteamID string `json:"steam_id,omitempty"`
	// SteamClanID holds the value of the "steam_clan_id" field.
	SteamClanID string `json:"steam_clan_id,omitempty"`
	// OwnerID holds the value of the "owner_id" field.
	OwnerID string `json:"owner_id,omitempty"`
	// SteamRoom holds the value of the "steam_room" field.
	SteamRoom string `json:"steam_room,omitempty"`
	// Session holds the value of the "session" field.
	Session string `json:"session,omitempty"`
	// Address holds the value of the "address" field.
	Address string `json:"address,omitempty"`
	// Port holds the value of the "port" field.
	Port int `json:"port,omitempty"`
	// Host holds the value of the "host" field.
	Host string `json:"host,omitempty"`
	// Platform holds the value of the "platform" field.
	Platform string `json:"platform,omitempty"`
	// ClanOnly holds the value of the "clan_only" field.
	ClanOnly bool `json:"clan_only,omitempty"`
	// LanOnly holds the value of the "lan_only" field.
	LanOnly bool `json:"lan_only,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// GameMode holds the value of the "game_mode" field.
	GameMode string `json:"game_mode,omitempty"`
	// Intent holds the value of the "intent" field.
	Intent string `json:"intent,omitempty"`
	// Season holds the value of the "season" field.
	Season string `json:"season,omitempty"`
	// Version holds the value of the "version" field.
	Version int `json:"version,omitempty"`
	// MaxOnline holds the value of the "max_online" field.
	MaxOnline int `json:"max_online,omitempty"`
	// Online holds the value of the "online" field.
	Online int `json:"online,omitempty"`
	// Level holds the value of the "level" field.
	Level int `json:"level,omitempty"`
	// Mod holds the value of the "mod" field.
	Mod bool `json:"mod,omitempty"`
	// Pvp holds the value of the "pvp" field.
	Pvp bool `json:"pvp,omitempty"`
	// Password holds the value of the "password" field.
	Password bool `json:"password,omitempty"`
	// Dedicated holds the value of the "dedicated" field.
	Dedicated bool `json:"dedicated,omitempty"`
	// ClientHosted holds the value of the "client_hosted" field.
	ClientHosted bool `json:"client_hosted,omitempty"`
	// AllowNewPlayers holds the value of the "allow_new_players" field.
	AllowNewPlayers bool `json:"allow_new_players,omitempty"`
	// ServerPaused holds the value of the "server_paused" field.
	ServerPaused bool `json:"server_paused,omitempty"`
	// FriendOnly holds the value of the "friend_only" field.
	FriendOnly bool `json:"friend_only,omitempty"`
	// QueryVersion holds the value of the "query_version" field.
	QueryVersion int64 `json:"query_version,omitempty"`
	// Country holds the value of the "country" field.
	Country string `json:"country,omitempty"`
	// Continent holds the value of the "continent" field.
	Continent string `json:"continent,omitempty"`
	// CountryCode holds the value of the "country_code" field.
	CountryCode string `json:"country_code,omitempty"`
	// City holds the value of the "city" field.
	City string `json:"city,omitempty"`
	// Region holds the value of the "region" field.
	Region string `json:"region,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ServerQuery when eager-loading is set.
	Edges        ServerEdges `json:"edges"`
	selectValues sql.SelectValues
}

// ServerEdges holds the relations/edges for other nodes in the graph.
type ServerEdges struct {
	// Tags holds the value of the tags edge.
	Tags []*Tag `json:"tags,omitempty"`
	// Secondaries holds the value of the secondaries edge.
	Secondaries []*Secondary `json:"secondaries,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// TagsOrErr returns the Tags value or an error if the edge
// was not loaded in eager-loading.
func (e ServerEdges) TagsOrErr() ([]*Tag, error) {
	if e.loadedTypes[0] {
		return e.Tags, nil
	}
	return nil, &NotLoadedError{edge: "tags"}
}

// SecondariesOrErr returns the Secondaries value or an error if the edge
// was not loaded in eager-loading.
func (e ServerEdges) SecondariesOrErr() ([]*Secondary, error) {
	if e.loadedTypes[1] {
		return e.Secondaries, nil
	}
	return nil, &NotLoadedError{edge: "secondaries"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Server) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case server.FieldClanOnly, server.FieldLanOnly, server.FieldMod, server.FieldPvp, server.FieldPassword, server.FieldDedicated, server.FieldClientHosted, server.FieldAllowNewPlayers, server.FieldServerPaused, server.FieldFriendOnly:
			values[i] = new(sql.NullBool)
		case server.FieldID, server.FieldPort, server.FieldVersion, server.FieldMaxOnline, server.FieldOnline, server.FieldLevel, server.FieldQueryVersion:
			values[i] = new(sql.NullInt64)
		case server.FieldGUID, server.FieldRowID, server.FieldSteamID, server.FieldSteamClanID, server.FieldOwnerID, server.FieldSteamRoom, server.FieldSession, server.FieldAddress, server.FieldHost, server.FieldPlatform, server.FieldName, server.FieldGameMode, server.FieldIntent, server.FieldSeason, server.FieldCountry, server.FieldContinent, server.FieldCountryCode, server.FieldCity, server.FieldRegion:
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Server fields.
func (s *Server) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case server.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			s.ID = int(value.Int64)
		case server.FieldGUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field guid", values[i])
			} else if value.Valid {
				s.GUID = value.String
			}
		case server.FieldRowID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field row_id", values[i])
			} else if value.Valid {
				s.RowID = value.String
			}
		case server.FieldSteamID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field steam_id", values[i])
			} else if value.Valid {
				s.SteamID = value.String
			}
		case server.FieldSteamClanID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field steam_clan_id", values[i])
			} else if value.Valid {
				s.SteamClanID = value.String
			}
		case server.FieldOwnerID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field owner_id", values[i])
			} else if value.Valid {
				s.OwnerID = value.String
			}
		case server.FieldSteamRoom:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field steam_room", values[i])
			} else if value.Valid {
				s.SteamRoom = value.String
			}
		case server.FieldSession:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field session", values[i])
			} else if value.Valid {
				s.Session = value.String
			}
		case server.FieldAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field address", values[i])
			} else if value.Valid {
				s.Address = value.String
			}
		case server.FieldPort:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field port", values[i])
			} else if value.Valid {
				s.Port = int(value.Int64)
			}
		case server.FieldHost:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field host", values[i])
			} else if value.Valid {
				s.Host = value.String
			}
		case server.FieldPlatform:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field platform", values[i])
			} else if value.Valid {
				s.Platform = value.String
			}
		case server.FieldClanOnly:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field clan_only", values[i])
			} else if value.Valid {
				s.ClanOnly = value.Bool
			}
		case server.FieldLanOnly:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field lan_only", values[i])
			} else if value.Valid {
				s.LanOnly = value.Bool
			}
		case server.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				s.Name = value.String
			}
		case server.FieldGameMode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field game_mode", values[i])
			} else if value.Valid {
				s.GameMode = value.String
			}
		case server.FieldIntent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field intent", values[i])
			} else if value.Valid {
				s.Intent = value.String
			}
		case server.FieldSeason:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field season", values[i])
			} else if value.Valid {
				s.Season = value.String
			}
		case server.FieldVersion:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				s.Version = int(value.Int64)
			}
		case server.FieldMaxOnline:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field max_online", values[i])
			} else if value.Valid {
				s.MaxOnline = int(value.Int64)
			}
		case server.FieldOnline:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field online", values[i])
			} else if value.Valid {
				s.Online = int(value.Int64)
			}
		case server.FieldLevel:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field level", values[i])
			} else if value.Valid {
				s.Level = int(value.Int64)
			}
		case server.FieldMod:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field mod", values[i])
			} else if value.Valid {
				s.Mod = value.Bool
			}
		case server.FieldPvp:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field pvp", values[i])
			} else if value.Valid {
				s.Pvp = value.Bool
			}
		case server.FieldPassword:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field password", values[i])
			} else if value.Valid {
				s.Password = value.Bool
			}
		case server.FieldDedicated:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field dedicated", values[i])
			} else if value.Valid {
				s.Dedicated = value.Bool
			}
		case server.FieldClientHosted:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field client_hosted", values[i])
			} else if value.Valid {
				s.ClientHosted = value.Bool
			}
		case server.FieldAllowNewPlayers:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field allow_new_players", values[i])
			} else if value.Valid {
				s.AllowNewPlayers = value.Bool
			}
		case server.FieldServerPaused:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field server_paused", values[i])
			} else if value.Valid {
				s.ServerPaused = value.Bool
			}
		case server.FieldFriendOnly:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field friend_only", values[i])
			} else if value.Valid {
				s.FriendOnly = value.Bool
			}
		case server.FieldQueryVersion:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field query_version", values[i])
			} else if value.Valid {
				s.QueryVersion = value.Int64
			}
		case server.FieldCountry:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country", values[i])
			} else if value.Valid {
				s.Country = value.String
			}
		case server.FieldContinent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field continent", values[i])
			} else if value.Valid {
				s.Continent = value.String
			}
		case server.FieldCountryCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field country_code", values[i])
			} else if value.Valid {
				s.CountryCode = value.String
			}
		case server.FieldCity:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field city", values[i])
			} else if value.Valid {
				s.City = value.String
			}
		case server.FieldRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region", values[i])
			} else if value.Valid {
				s.Region = value.String
			}
		default:
			s.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Server.
// This includes values selected through modifiers, order, etc.
func (s *Server) Value(name string) (ent.Value, error) {
	return s.selectValues.Get(name)
}

// QueryTags queries the "tags" edge of the Server entity.
func (s *Server) QueryTags() *TagQuery {
	return NewServerClient(s.config).QueryTags(s)
}

// QuerySecondaries queries the "secondaries" edge of the Server entity.
func (s *Server) QuerySecondaries() *SecondaryQuery {
	return NewServerClient(s.config).QuerySecondaries(s)
}

// Update returns a builder for updating this Server.
// Note that you need to call Server.Unwrap() before calling this method if this Server
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Server) Update() *ServerUpdateOne {
	return NewServerClient(s.config).UpdateOne(s)
}

// Unwrap unwraps the Server entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (s *Server) Unwrap() *Server {
	_tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("ent: Server is not a transactional entity")
	}
	s.config.driver = _tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Server) String() string {
	var builder strings.Builder
	builder.WriteString("Server(")
	builder.WriteString(fmt.Sprintf("id=%v, ", s.ID))
	builder.WriteString("guid=")
	builder.WriteString(s.GUID)
	builder.WriteString(", ")
	builder.WriteString("row_id=")
	builder.WriteString(s.RowID)
	builder.WriteString(", ")
	builder.WriteString("steam_id=")
	builder.WriteString(s.SteamID)
	builder.WriteString(", ")
	builder.WriteString("steam_clan_id=")
	builder.WriteString(s.SteamClanID)
	builder.WriteString(", ")
	builder.WriteString("owner_id=")
	builder.WriteString(s.OwnerID)
	builder.WriteString(", ")
	builder.WriteString("steam_room=")
	builder.WriteString(s.SteamRoom)
	builder.WriteString(", ")
	builder.WriteString("session=")
	builder.WriteString(s.Session)
	builder.WriteString(", ")
	builder.WriteString("address=")
	builder.WriteString(s.Address)
	builder.WriteString(", ")
	builder.WriteString("port=")
	builder.WriteString(fmt.Sprintf("%v", s.Port))
	builder.WriteString(", ")
	builder.WriteString("host=")
	builder.WriteString(s.Host)
	builder.WriteString(", ")
	builder.WriteString("platform=")
	builder.WriteString(s.Platform)
	builder.WriteString(", ")
	builder.WriteString("clan_only=")
	builder.WriteString(fmt.Sprintf("%v", s.ClanOnly))
	builder.WriteString(", ")
	builder.WriteString("lan_only=")
	builder.WriteString(fmt.Sprintf("%v", s.LanOnly))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(s.Name)
	builder.WriteString(", ")
	builder.WriteString("game_mode=")
	builder.WriteString(s.GameMode)
	builder.WriteString(", ")
	builder.WriteString("intent=")
	builder.WriteString(s.Intent)
	builder.WriteString(", ")
	builder.WriteString("season=")
	builder.WriteString(s.Season)
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(fmt.Sprintf("%v", s.Version))
	builder.WriteString(", ")
	builder.WriteString("max_online=")
	builder.WriteString(fmt.Sprintf("%v", s.MaxOnline))
	builder.WriteString(", ")
	builder.WriteString("online=")
	builder.WriteString(fmt.Sprintf("%v", s.Online))
	builder.WriteString(", ")
	builder.WriteString("level=")
	builder.WriteString(fmt.Sprintf("%v", s.Level))
	builder.WriteString(", ")
	builder.WriteString("mod=")
	builder.WriteString(fmt.Sprintf("%v", s.Mod))
	builder.WriteString(", ")
	builder.WriteString("pvp=")
	builder.WriteString(fmt.Sprintf("%v", s.Pvp))
	builder.WriteString(", ")
	builder.WriteString("password=")
	builder.WriteString(fmt.Sprintf("%v", s.Password))
	builder.WriteString(", ")
	builder.WriteString("dedicated=")
	builder.WriteString(fmt.Sprintf("%v", s.Dedicated))
	builder.WriteString(", ")
	builder.WriteString("client_hosted=")
	builder.WriteString(fmt.Sprintf("%v", s.ClientHosted))
	builder.WriteString(", ")
	builder.WriteString("allow_new_players=")
	builder.WriteString(fmt.Sprintf("%v", s.AllowNewPlayers))
	builder.WriteString(", ")
	builder.WriteString("server_paused=")
	builder.WriteString(fmt.Sprintf("%v", s.ServerPaused))
	builder.WriteString(", ")
	builder.WriteString("friend_only=")
	builder.WriteString(fmt.Sprintf("%v", s.FriendOnly))
	builder.WriteString(", ")
	builder.WriteString("query_version=")
	builder.WriteString(fmt.Sprintf("%v", s.QueryVersion))
	builder.WriteString(", ")
	builder.WriteString("country=")
	builder.WriteString(s.Country)
	builder.WriteString(", ")
	builder.WriteString("continent=")
	builder.WriteString(s.Continent)
	builder.WriteString(", ")
	builder.WriteString("country_code=")
	builder.WriteString(s.CountryCode)
	builder.WriteString(", ")
	builder.WriteString("city=")
	builder.WriteString(s.City)
	builder.WriteString(", ")
	builder.WriteString("region=")
	builder.WriteString(s.Region)
	builder.WriteByte(')')
	return builder.String()
}

// Servers is a parsable slice of Server.
type Servers []*Server
